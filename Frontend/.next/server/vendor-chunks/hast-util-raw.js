"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-raw";
exports.ids = ["vendor-chunks/hast-util-raw"];
exports.modules = {

/***/ "(ssr)/./node_modules/hast-util-raw/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/hast-util-raw/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raw: () => (/* binding */ raw)\n/* harmony export */ });\n/* harmony import */ var _ungap_structured_clone__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ungap/structured-clone */ \"(ssr)/./node_modules/@ungap/structured-clone/esm/index.js\");\n/* harmony import */ var hast_util_from_parse5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hast-util-from-parse5 */ \"(ssr)/./node_modules/hast-util-from-parse5/lib/index.js\");\n/* harmony import */ var hast_util_to_parse5__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! hast-util-to-parse5 */ \"(ssr)/./node_modules/hast-util-to-parse5/lib/index.js\");\n/* harmony import */ var html_void_elements__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! html-void-elements */ \"(ssr)/./node_modules/html-void-elements/index.js\");\n/* harmony import */ var parse5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parse5 */ \"(ssr)/./node_modules/parse5/dist/index.js\");\n/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-position */ \"(ssr)/./node_modules/unist-util-position/lib/index.js\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var web_namespaces__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! web-namespaces */ \"(ssr)/./node_modules/web-namespaces/index.js\");\n/* harmony import */ var zwitch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zwitch */ \"(ssr)/./node_modules/zwitch/index.js\");\n/**\n * @import {Options} from 'hast-util-raw'\n * @import {Comment, Doctype, Element, Nodes, RootContent, Root, Text} from 'hast'\n * @import {Raw} from 'mdast-util-to-hast'\n * @import {DefaultTreeAdapterMap, ParserOptions} from 'parse5'\n * @import {Point} from 'unist'\n */ /**\n * @typedef State\n *   Info passed around about the current state.\n * @property {(node: Nodes) => undefined} handle\n *   Add a hast node to the parser.\n * @property {Options} options\n *   User configuration.\n * @property {Parser<DefaultTreeAdapterMap>} parser\n *   Current parser.\n * @property {boolean} stitches\n *   Whether there are stitches.\n */ /**\n * @typedef Stitch\n *   Custom comment-like value we pass through parse5, which contains a\n *   replacement node that weâ€™ll swap back in afterwards.\n * @property {'comment'} type\n *   Node type.\n * @property {{stitch: Nodes}} value\n *   Replacement value.\n */ \n\n\n\n\n\n\n\n\nconst gfmTagfilterExpression = /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\\t\\n\\f\\r />])/gi;\n// Node types associated with MDX.\n// <https://github.com/mdx-js/mdx/blob/8a56312/packages/mdx/lib/node-types.js>\nconst knownMdxNames = new Set([\n    \"mdxFlowExpression\",\n    \"mdxJsxFlowElement\",\n    \"mdxJsxTextElement\",\n    \"mdxTextExpression\",\n    \"mdxjsEsm\"\n]);\n/** @type {ParserOptions<DefaultTreeAdapterMap>} */ const parseOptions = {\n    sourceCodeLocationInfo: true,\n    scriptingEnabled: false\n};\n/**\n * Pass a hast tree through an HTML parser, which will fix nesting, and turn\n * raw nodes into actual nodes.\n *\n * @param {Nodes} tree\n *   Original hast tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   Parsed again tree.\n */ function raw(tree, options) {\n    const document = documentMode(tree);\n    /** @type {(node: Nodes, state: State) => undefined} */ const one = (0,zwitch__WEBPACK_IMPORTED_MODULE_1__.zwitch)(\"type\", {\n        handlers: {\n            root,\n            element,\n            text,\n            comment,\n            doctype,\n            raw: handleRaw\n        },\n        unknown\n    });\n    /** @type {State} */ const state = {\n        parser: document ? new parse5__WEBPACK_IMPORTED_MODULE_0__.Parser(parseOptions) : parse5__WEBPACK_IMPORTED_MODULE_0__.Parser.getFragmentParser(undefined, parseOptions),\n        handle (node) {\n            one(node, state);\n        },\n        stitches: false,\n        options: options || {}\n    };\n    one(tree, state);\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointStart)());\n    const p5 = document ? state.parser.document : state.parser.getFragment();\n    const result = (0,hast_util_from_parse5__WEBPACK_IMPORTED_MODULE_3__.fromParse5)(p5, {\n        // To do: support `space`?\n        file: state.options.file\n    });\n    if (state.stitches) {\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_4__.visit)(result, \"comment\", function(node, index, parent) {\n            const stitch = /** @type {unknown} */ node;\n            if (stitch.value.stitch && parent && index !== undefined) {\n                /** @type {Array<RootContent>} */ const siblings = parent.children;\n                // @ts-expect-error: assume the stitch is allowed.\n                siblings[index] = stitch.value.stitch;\n                return index;\n            }\n        });\n    }\n    // Unpack if possible and when not given a `root`.\n    if (result.type === \"root\" && result.children.length === 1 && result.children[0].type === tree.type) {\n        return result.children[0];\n    }\n    return result;\n}\n/**\n * Transform all nodes\n *\n * @param {Array<RootContent>} nodes\n *   hast content.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function all(nodes, state) {\n    let index = -1;\n    /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */ if (nodes) {\n        while(++index < nodes.length){\n            state.handle(nodes[index]);\n        }\n    }\n}\n/**\n * Transform a root.\n *\n * @param {Root} node\n *   hast root node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function root(node, state) {\n    all(node.children, state);\n}\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   hast element node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function element(node, state) {\n    startTag(node, state);\n    all(node.children, state);\n    endTag(node, state);\n}\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   hast text node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function text(node, state) {\n    // Allow `DATA` through `PLAINTEXT`,\n    // but when hanging in a tag for example,\n    // switch back to `DATA`.\n    // Note: `State` is not exposed by `parse5`, so these numbers are fragile.\n    // See: <https://github.com/inikulin/parse5/blob/46cba43/packages/parse5/lib/tokenizer/index.ts#L58>\n    if (state.parser.tokenizer.state > 4) {\n        state.parser.tokenizer.state = 0;\n    }\n    /** @type {Token.CharacterToken} */ const token = {\n        type: parse5__WEBPACK_IMPORTED_MODULE_0__.Token.TokenType.CHARACTER,\n        chars: node.value,\n        location: createParse5Location(node)\n    };\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointStart)(node));\n    // @ts-expect-error: private.\n    state.parser.currentToken = token;\n    // @ts-expect-error: private.\n    state.parser._processToken(state.parser.currentToken);\n}\n/**\n * Transform a doctype.\n *\n * @param {Doctype} node\n *   hast doctype node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function doctype(node, state) {\n    /** @type {Token.DoctypeToken} */ const token = {\n        type: parse5__WEBPACK_IMPORTED_MODULE_0__.Token.TokenType.DOCTYPE,\n        name: \"html\",\n        forceQuirks: false,\n        publicId: \"\",\n        systemId: \"\",\n        location: createParse5Location(node)\n    };\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointStart)(node));\n    // @ts-expect-error: private.\n    state.parser.currentToken = token;\n    // @ts-expect-error: private.\n    state.parser._processToken(state.parser.currentToken);\n}\n/**\n * Transform a stitch.\n *\n * @param {Nodes} node\n *   unknown node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function stitch(node, state) {\n    // Mark that there are stitches, so we need to walk the tree and revert them.\n    state.stitches = true;\n    /** @type {Nodes} */ const clone = cloneWithoutChildren(node);\n    // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n    // passed through node).\n    if (\"children\" in node && \"children\" in clone) {\n        // Root in root out.\n        const fakeRoot = /** @type {Root} */ raw({\n            type: \"root\",\n            children: node.children\n        }, state.options);\n        clone.children = fakeRoot.children;\n    }\n    // Hack: `value` is supposed to be a string, but as none of the tools\n    // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n    // through.\n    comment({\n        type: \"comment\",\n        value: {\n            stitch: clone\n        }\n    }, state);\n}\n/**\n * Transform a comment (or stitch).\n *\n * @param {Comment | Stitch} node\n *   hast comment node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function comment(node, state) {\n    /** @type {string} */ // @ts-expect-error: we pass stitches through.\n    const data = node.value;\n    /** @type {Token.CommentToken} */ const token = {\n        type: parse5__WEBPACK_IMPORTED_MODULE_0__.Token.TokenType.COMMENT,\n        data,\n        location: createParse5Location(node)\n    };\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointStart)(node));\n    // @ts-expect-error: private.\n    state.parser.currentToken = token;\n    // @ts-expect-error: private.\n    state.parser._processToken(state.parser.currentToken);\n}\n/**\n * Transform a raw node.\n *\n * @param {Raw} node\n *   hast raw node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function handleRaw(node, state) {\n    // Reset preprocessor:\n    // See: <https://github.com/inikulin/parse5/blob/6f7ca60/packages/parse5/lib/tokenizer/preprocessor.ts#L18-L31>.\n    state.parser.tokenizer.preprocessor.html = \"\";\n    state.parser.tokenizer.preprocessor.pos = -1;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.lastGapPos = -2;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.gapStack = [];\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.skipNextNewLine = false;\n    state.parser.tokenizer.preprocessor.lastChunkWritten = false;\n    state.parser.tokenizer.preprocessor.endOfChunkHit = false;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.isEol = false;\n    // Now pass `node.value`.\n    setPoint(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointStart)(node));\n    state.parser.tokenizer.write(state.options.tagfilter ? node.value.replace(gfmTagfilterExpression, \"&lt;$1$2\") : node.value, false);\n    // @ts-expect-error: private.\n    state.parser.tokenizer._runParsingLoop();\n    // Character references hang, so if we ended there, we need to flush\n    // those too.\n    // We reset the preprocessor as if the document ends here.\n    // Then one single call to the relevant state does the trick, parse5\n    // consumes the whole token.\n    // Note: `State` is not exposed by `parse5`, so these numbers are fragile.\n    // See: <https://github.com/inikulin/parse5/blob/46cba43/packages/parse5/lib/tokenizer/index.ts#L58>\n    // Note: a change to `parse5`, which breaks this, was merged but not released.\n    // Investigate when it is.\n    // To do: remove next major.\n    /* c8 ignore next 12 -- removed in <https://github.com/inikulin/parse5/pull/897> */ if (state.parser.tokenizer.state === 72 /* NAMED_CHARACTER_REFERENCE */  || // @ts-expect-error: removed.\n    state.parser.tokenizer.state === 78 /* NUMERIC_CHARACTER_REFERENCE_END */ ) {\n        state.parser.tokenizer.preprocessor.lastChunkWritten = true;\n        /** @type {number} */ // @ts-expect-error: private.\n        const cp = state.parser.tokenizer._consume();\n        // @ts-expect-error: private.\n        state.parser.tokenizer._callState(cp);\n    }\n}\n/**\n * Crash on an unknown node.\n *\n * @param {unknown} node_\n *   unknown node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Never.\n */ function unknown(node_, state) {\n    const node = /** @type {Nodes} */ node_;\n    if (state.options.passThrough && state.options.passThrough.includes(node.type)) {\n        stitch(node, state);\n    } else {\n        let extra = \"\";\n        if (knownMdxNames.has(node.type)) {\n            extra = \". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax\";\n        }\n        throw new Error(\"Cannot compile `\" + node.type + \"` node\" + extra);\n    }\n}\n/**\n * Reset the tokenizer of a parser.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Point | undefined} point\n *   Point.\n * @returns {undefined}\n *   Nothing.\n */ function resetTokenizer(state, point) {\n    setPoint(state, point);\n    // Process final characters if theyâ€™re still there after hibernating.\n    /** @type {Token.CharacterToken} */ // @ts-expect-error: private.\n    const token = state.parser.tokenizer.currentCharacterToken;\n    if (token && token.location) {\n        token.location.endLine = state.parser.tokenizer.preprocessor.line;\n        token.location.endCol = state.parser.tokenizer.preprocessor.col + 1;\n        token.location.endOffset = state.parser.tokenizer.preprocessor.offset + 1;\n        // @ts-expect-error: private.\n        state.parser.currentToken = token;\n        // @ts-expect-error: private.\n        state.parser._processToken(state.parser.currentToken);\n    }\n    // Reset tokenizer:\n    // See: <https://github.com/inikulin/parse5/blob/6f7ca60/packages/parse5/lib/tokenizer/index.ts#L187-L223>.\n    // Especially putting it back in the `data` state is useful: some elements,\n    // like textareas and iframes, change the state.\n    // See GH-7.\n    // But also if broken HTML is in `raw`, and then a correct element is given.\n    // See GH-11.\n    // @ts-expect-error: private.\n    state.parser.tokenizer.paused = false;\n    // @ts-expect-error: private.\n    state.parser.tokenizer.inLoop = false;\n    // Note: donâ€™t reset `state`, `inForeignNode`, or `lastStartTagName`, we\n    // manually update those when needed.\n    state.parser.tokenizer.active = false;\n    // @ts-expect-error: private.\n    state.parser.tokenizer.returnState = parse5__WEBPACK_IMPORTED_MODULE_0__.TokenizerMode.DATA;\n    // @ts-expect-error: private.\n    state.parser.tokenizer.charRefCode = -1;\n    // @ts-expect-error: private.\n    state.parser.tokenizer.consumedAfterSnapshot = -1;\n    // @ts-expect-error: private.\n    state.parser.tokenizer.currentLocation = null;\n    // @ts-expect-error: private.\n    state.parser.tokenizer.currentCharacterToken = null;\n    // @ts-expect-error: private.\n    state.parser.tokenizer.currentToken = null;\n    // @ts-expect-error: private.\n    state.parser.tokenizer.currentAttr = {\n        name: \"\",\n        value: \"\"\n    };\n}\n/**\n * Set current location.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Point | undefined} point\n *   Point.\n * @returns {undefined}\n *   Nothing.\n */ function setPoint(state, point) {\n    if (point && point.offset !== undefined) {\n        /** @type {Token.Location} */ const location = {\n            startLine: point.line,\n            startCol: point.column,\n            startOffset: point.offset,\n            endLine: -1,\n            endCol: -1,\n            endOffset: -1\n        };\n        // @ts-expect-error: private.\n        // type-coverage:ignore-next-line\n        state.parser.tokenizer.preprocessor.lineStartPos = -point.column + 1 // Looks weird, but ensures we get correct positional info.\n        ;\n        state.parser.tokenizer.preprocessor.droppedBufferSize = point.offset;\n        state.parser.tokenizer.preprocessor.line = point.line;\n        // @ts-expect-error: private.\n        state.parser.tokenizer.currentLocation = location;\n    }\n}\n/**\n * Emit a start tag.\n *\n * @param {Element} node\n *   Element.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function startTag(node, state) {\n    const tagName = node.tagName.toLowerCase();\n    // Ignore tags if weâ€™re in plain text.\n    if (state.parser.tokenizer.state === parse5__WEBPACK_IMPORTED_MODULE_0__.TokenizerMode.PLAINTEXT) return;\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointStart)(node));\n    const current = state.parser.openElements.current;\n    let ns = \"namespaceURI\" in current ? current.namespaceURI : web_namespaces__WEBPACK_IMPORTED_MODULE_5__.webNamespaces.html;\n    if (ns === web_namespaces__WEBPACK_IMPORTED_MODULE_5__.webNamespaces.html && tagName === \"svg\") {\n        ns = web_namespaces__WEBPACK_IMPORTED_MODULE_5__.webNamespaces.svg;\n    }\n    const result = (0,hast_util_to_parse5__WEBPACK_IMPORTED_MODULE_6__.toParse5)(// Shallow clone to not delve into `children`: we only need the attributes.\n    {\n        ...node,\n        children: []\n    }, {\n        space: ns === web_namespaces__WEBPACK_IMPORTED_MODULE_5__.webNamespaces.svg ? \"svg\" : \"html\"\n    });\n    /** @type {Token.TagToken} */ const tag = {\n        type: parse5__WEBPACK_IMPORTED_MODULE_0__.Token.TokenType.START_TAG,\n        tagName,\n        tagID: parse5__WEBPACK_IMPORTED_MODULE_0__.html.getTagID(tagName),\n        // We always send start and end tags.\n        selfClosing: false,\n        ackSelfClosing: false,\n        // Always element.\n        /* c8 ignore next */ attrs: \"attrs\" in result ? result.attrs : [],\n        location: createParse5Location(node)\n    };\n    // The HTML parsing algorithm works by doing half of the state management in\n    // the tokenizer and half in the parser.\n    // We canâ€™t use the tokenizer here, as we donâ€™t have strings.\n    // So we act *as if* the tokenizer emits tokens:\n    // @ts-expect-error: private.\n    state.parser.currentToken = tag;\n    // @ts-expect-error: private.\n    state.parser._processToken(state.parser.currentToken);\n    // â€¦but then we still need a bunch of work that the tokenizer would normally\n    // do, such as:\n    // Set a tag name, similar to how the tokenizer would do it.\n    state.parser.tokenizer.lastStartTagName = tagName;\n// `inForeignNode` is correctly set by the parser.\n}\n/**\n * Emit an end tag.\n *\n * @param {Element} node\n *   Element.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function endTag(node, state) {\n    const tagName = node.tagName.toLowerCase();\n    // Do not emit closing tags for HTML void elements.\n    if (!state.parser.tokenizer.inForeignNode && html_void_elements__WEBPACK_IMPORTED_MODULE_7__.htmlVoidElements.includes(tagName)) {\n        return;\n    }\n    // Ignore tags if weâ€™re in plain text.\n    if (state.parser.tokenizer.state === parse5__WEBPACK_IMPORTED_MODULE_0__.TokenizerMode.PLAINTEXT) return;\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointEnd)(node));\n    /** @type {Token.TagToken} */ const tag = {\n        type: parse5__WEBPACK_IMPORTED_MODULE_0__.Token.TokenType.END_TAG,\n        tagName,\n        tagID: parse5__WEBPACK_IMPORTED_MODULE_0__.html.getTagID(tagName),\n        selfClosing: false,\n        ackSelfClosing: false,\n        attrs: [],\n        location: createParse5Location(node)\n    };\n    // The HTML parsing algorithm works by doing half of the state management in\n    // the tokenizer and half in the parser.\n    // We canâ€™t use the tokenizer here, as we donâ€™t have strings.\n    // So we act *as if* the tokenizer emits tokens:\n    // @ts-expect-error: private.\n    state.parser.currentToken = tag;\n    // @ts-expect-error: private.\n    state.parser._processToken(state.parser.currentToken);\n    // â€¦but then we still need a bunch of work that the tokenizer would normally\n    // do, such as:\n    // Switch back to the data state after alternative states that donâ€™t accept\n    // tags:\n    if (// Current element is closed.\n    tagName === state.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`\n    (state.parser.tokenizer.state === parse5__WEBPACK_IMPORTED_MODULE_0__.TokenizerMode.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`\n    state.parser.tokenizer.state === parse5__WEBPACK_IMPORTED_MODULE_0__.TokenizerMode.RAWTEXT || // `<script>`\n    state.parser.tokenizer.state === parse5__WEBPACK_IMPORTED_MODULE_0__.TokenizerMode.SCRIPT_DATA)) {\n        state.parser.tokenizer.state = parse5__WEBPACK_IMPORTED_MODULE_0__.TokenizerMode.DATA;\n    }\n}\n/**\n * Check if `node` represents a whole document or a fragment.\n *\n * @param {Nodes} node\n *   hast node.\n * @returns {boolean}\n *   Whether this represents a whole document or a fragment.\n */ function documentMode(node) {\n    const head = node.type === \"root\" ? node.children[0] : node;\n    return Boolean(head && (head.type === \"doctype\" || head.type === \"element\" && head.tagName.toLowerCase() === \"html\"));\n}\n/**\n * Get a `parse5` location from a node.\n *\n * @param {Nodes | Stitch} node\n *   hast node.\n * @returns {Token.Location}\n *   `parse5` location.\n */ function createParse5Location(node) {\n    const start = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointStart)(node) || {\n        line: undefined,\n        column: undefined,\n        offset: undefined\n    };\n    const end = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointEnd)(node) || {\n        line: undefined,\n        column: undefined,\n        offset: undefined\n    };\n    /** @type {Record<keyof Token.Location, number | undefined>} */ const location = {\n        startLine: start.line,\n        startCol: start.column,\n        startOffset: start.offset,\n        endLine: end.line,\n        endCol: end.column,\n        endOffset: end.offset\n    };\n    // @ts-expect-error: unist point values can be `undefined` in hast, which\n    // `parse5` types donâ€™t want.\n    return location;\n}\n/**\n * @template {Nodes} NodeType\n *   Node type.\n * @param {NodeType} node\n *   Node to clone.\n * @returns {NodeType}\n *   Cloned node, without children.\n */ function cloneWithoutChildren(node) {\n    return \"children\" in node ? (0,_ungap_structured_clone__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n        ...node,\n        children: []\n    }) : (0,_ungap_structured_clone__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(node);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXJhdy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUVEOzs7Ozs7Ozs7OztDQVdDLEdBRUQ7Ozs7Ozs7O0NBUUMsR0FFb0Q7QUFDTDtBQUNKO0FBQ087QUFDTTtBQUNEO0FBQ2xCO0FBQ007QUFDZjtBQUU3QixNQUFNYSx5QkFDSjtBQUVGLGtDQUFrQztBQUNsQyw4RUFBOEU7QUFDOUUsTUFBTUMsZ0JBQWdCLElBQUlDLElBQUk7SUFDNUI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsaURBQWlELEdBQ2pELE1BQU1DLGVBQWU7SUFBQ0Msd0JBQXdCO0lBQU1DLGtCQUFrQjtBQUFLO0FBRTNFOzs7Ozs7Ozs7O0NBVUMsR0FDTSxTQUFTQyxJQUFJQyxJQUFJLEVBQUVDLE9BQU87SUFDL0IsTUFBTUMsV0FBV0MsYUFBYUg7SUFDOUIscURBQXFELEdBQ3JELE1BQU1JLE1BQU1aLDhDQUFNQSxDQUFDLFFBQVE7UUFDekJhLFVBQVU7WUFBQ0M7WUFBTUM7WUFBU0M7WUFBTUM7WUFBU0M7WUFBU1gsS0FBS1k7UUFBUztRQUNoRUM7SUFDRjtJQUVBLGtCQUFrQixHQUNsQixNQUFNQyxRQUFRO1FBQ1pDLFFBQVFaLFdBQ0osSUFBSWxCLDBDQUFNQSxDQUFDWSxnQkFDWFosMENBQU1BLENBQUMrQixpQkFBaUIsQ0FBQ0MsV0FBV3BCO1FBQ3hDcUIsUUFBT0MsSUFBSTtZQUNUZCxJQUFJYyxNQUFNTDtRQUNaO1FBQ0FNLFVBQVU7UUFDVmxCLFNBQVNBLFdBQVcsQ0FBQztJQUN2QjtJQUVBRyxJQUFJSixNQUFNYTtJQUNWTyxlQUFlUCxPQUFPeEIsK0RBQVVBO0lBRWhDLE1BQU1nQyxLQUFLbkIsV0FBV1csTUFBTUMsTUFBTSxDQUFDWixRQUFRLEdBQUdXLE1BQU1DLE1BQU0sQ0FBQ1EsV0FBVztJQUN0RSxNQUFNQyxTQUFTMUMsaUVBQVVBLENBQUN3QyxJQUFJ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LENBQUM4QixTQUFTO1FBQzVCK0QsTUFBTWpFO1FBQ05pRixRQUFRakY7UUFDUnFFLFFBQVFyRTtJQUNWO0lBRUEsNkRBQTZELEdBQzdELE1BQU0wQixXQUFXO1FBQ2ZxRCxXQUFXOEIsTUFBTTVDLElBQUk7UUFDckJlLFVBQVU2QixNQUFNNUIsTUFBTTtRQUN0QkMsYUFBYTJCLE1BQU14QyxNQUFNO1FBQ3pCTCxTQUFTOEMsSUFBSTdDLElBQUk7UUFDakJDLFFBQVE0QyxJQUFJN0IsTUFBTTtRQUNsQmIsV0FBVzBDLElBQUl6QyxNQUFNO0lBQ3ZCO0lBRUEseUVBQXlFO0lBQ3pFLDZCQUE2QjtJQUM3QixPQUFPM0M7QUFDVDtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTVSxxQkFBcUJsQyxJQUFJO0lBQ2hDLE9BQU8sY0FBY0EsT0FDakJ0QyxtRUFBZUEsQ0FBQztRQUFDLEdBQUdzQyxJQUFJO1FBQUVZLFVBQVUsRUFBRTtJQUFBLEtBQ3RDbEQsbUVBQWVBLENBQUNzQztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbnRhaW5lcmRfbXVsdGlub3Rlcy8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtcmF3L2xpYi9pbmRleC5qcz8wM2Y3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7T3B0aW9uc30gZnJvbSAnaGFzdC11dGlsLXJhdydcbiAqIEBpbXBvcnQge0NvbW1lbnQsIERvY3R5cGUsIEVsZW1lbnQsIE5vZGVzLCBSb290Q29udGVudCwgUm9vdCwgVGV4dH0gZnJvbSAnaGFzdCdcbiAqIEBpbXBvcnQge1Jhd30gZnJvbSAnbWRhc3QtdXRpbC10by1oYXN0J1xuICogQGltcG9ydCB7RGVmYXVsdFRyZWVBZGFwdGVyTWFwLCBQYXJzZXJPcHRpb25zfSBmcm9tICdwYXJzZTUnXG4gKiBAaW1wb3J0IHtQb2ludH0gZnJvbSAndW5pc3QnXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBTdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcHJvcGVydHkgeyhub2RlOiBOb2RlcykgPT4gdW5kZWZpbmVkfSBoYW5kbGVcbiAqICAgQWRkIGEgaGFzdCBub2RlIHRvIHRoZSBwYXJzZXIuXG4gKiBAcHJvcGVydHkge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgVXNlciBjb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtQYXJzZXI8RGVmYXVsdFRyZWVBZGFwdGVyTWFwPn0gcGFyc2VyXG4gKiAgIEN1cnJlbnQgcGFyc2VyLlxuICogQHByb3BlcnR5IHtib29sZWFufSBzdGl0Y2hlc1xuICogICBXaGV0aGVyIHRoZXJlIGFyZSBzdGl0Y2hlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFN0aXRjaFxuICogICBDdXN0b20gY29tbWVudC1saWtlIHZhbHVlIHdlIHBhc3MgdGhyb3VnaCBwYXJzZTUsIHdoaWNoIGNvbnRhaW5zIGFcbiAqICAgcmVwbGFjZW1lbnQgbm9kZSB0aGF0IHdl4oCZbGwgc3dhcCBiYWNrIGluIGFmdGVyd2FyZHMuXG4gKiBAcHJvcGVydHkgeydjb21tZW50J30gdHlwZVxuICogICBOb2RlIHR5cGUuXG4gKiBAcHJvcGVydHkge3tzdGl0Y2g6IE5vZGVzfX0gdmFsdWVcbiAqICAgUmVwbGFjZW1lbnQgdmFsdWUuXG4gKi9cblxuaW1wb3J0IHN0cnVjdHVyZWRDbG9uZSBmcm9tICdAdW5nYXAvc3RydWN0dXJlZC1jbG9uZSdcbmltcG9ydCB7ZnJvbVBhcnNlNX0gZnJvbSAnaGFzdC11dGlsLWZyb20tcGFyc2U1J1xuaW1wb3J0IHt0b1BhcnNlNX0gZnJvbSAnaGFzdC11dGlsLXRvLXBhcnNlNSdcbmltcG9ydCB7aHRtbFZvaWRFbGVtZW50c30gZnJvbSAnaHRtbC12b2lkLWVsZW1lbnRzJ1xuaW1wb3J0IHtQYXJzZXIsIFRva2VuLCBUb2tlbml6ZXJNb2RlLCBodG1sfSBmcm9tICdwYXJzZTUnXG5pbXBvcnQge3BvaW50RW5kLCBwb2ludFN0YXJ0fSBmcm9tICd1bmlzdC11dGlsLXBvc2l0aW9uJ1xuaW1wb3J0IHt2aXNpdH0gZnJvbSAndW5pc3QtdXRpbC12aXNpdCdcbmltcG9ydCB7d2ViTmFtZXNwYWNlc30gZnJvbSAnd2ViLW5hbWVzcGFjZXMnXG5pbXBvcnQge3p3aXRjaH0gZnJvbSAnendpdGNoJ1xuXG5jb25zdCBnZm1UYWdmaWx0ZXJFeHByZXNzaW9uID1cbiAgLzwoXFwvPykoaWZyYW1lfG5vZW1iZWR8bm9mcmFtZXN8cGxhaW50ZXh0fHNjcmlwdHxzdHlsZXx0ZXh0YXJlYXx0aXRsZXx4bXApKD89W1xcdFxcblxcZlxcciAvPl0pL2dpXG5cbi8vIE5vZGUgdHlwZXMgYXNzb2NpYXRlZCB3aXRoIE1EWC5cbi8vIDxodHRwczovL2dpdGh1Yi5jb20vbWR4LWpzL21keC9ibG9iLzhhNTYzMTIvcGFja2FnZXMvbWR4L2xpYi9ub2RlLXR5cGVzLmpzPlxuY29uc3Qga25vd25NZHhOYW1lcyA9IG5ldyBTZXQoW1xuICAnbWR4Rmxvd0V4cHJlc3Npb24nLFxuICAnbWR4SnN4Rmxvd0VsZW1lbnQnLFxuICAnbWR4SnN4VGV4dEVsZW1lbnQnLFxuICAnbWR4VGV4dEV4cHJlc3Npb24nLFxuICAnbWR4anNFc20nXG5dKVxuXG4vKiogQHR5cGUge1BhcnNlck9wdGlvbnM8RGVmYXVsdFRyZWVBZGFwdGVyTWFwPn0gKi9cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHtzb3VyY2VDb2RlTG9jYXRpb25JbmZvOiB0cnVlLCBzY3JpcHRpbmdFbmFibGVkOiBmYWxzZX1cblxuLyoqXG4gKiBQYXNzIGEgaGFzdCB0cmVlIHRocm91Z2ggYW4gSFRNTCBwYXJzZXIsIHdoaWNoIHdpbGwgZml4IG5lc3RpbmcsIGFuZCB0dXJuXG4gKiByYXcgbm9kZXMgaW50byBhY3R1YWwgbm9kZXMuXG4gKlxuICogQHBhcmFtIHtOb2Rlc30gdHJlZVxuICogICBPcmlnaW5hbCBoYXN0IHRyZWUgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtOb2Rlc31cbiAqICAgUGFyc2VkIGFnYWluIHRyZWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYXcodHJlZSwgb3B0aW9ucykge1xuICBjb25zdCBkb2N1bWVudCA9IGRvY3VtZW50TW9kZSh0cmVlKVxuICAvKiogQHR5cGUgeyhub2RlOiBOb2Rlcywgc3RhdGU6IFN0YXRlKSA9PiB1bmRlZmluZWR9ICovXG4gIGNvbnN0IG9uZSA9IHp3aXRjaCgndHlwZScsIHtcbiAgICBoYW5kbGVyczoge3Jvb3QsIGVsZW1lbnQsIHRleHQsIGNvbW1lbnQsIGRvY3R5cGUsIHJhdzogaGFuZGxlUmF3fSxcbiAgICB1bmtub3duXG4gIH0pXG5cbiAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgcGFyc2VyOiBkb2N1bWVudFxuICAgICAgPyBuZXcgUGFyc2VyKHBhcnNlT3B0aW9ucylcbiAgICAgIDogUGFyc2VyLmdldEZyYWdtZW50UGFyc2VyKHVuZGVmaW5lZCwgcGFyc2VPcHRpb25zKSxcbiAgICBoYW5kbGUobm9kZSkge1xuICAgICAgb25lKG5vZGUsIHN0YXRlKVxuICAgIH0sXG4gICAgc3RpdGNoZXM6IGZhbHNlLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge31cbiAgfVxuXG4gIG9uZSh0cmVlLCBzdGF0ZSlcbiAgcmVzZXRUb2tlbml6ZXIoc3RhdGUsIHBvaW50U3RhcnQoKSlcblxuICBjb25zdCBwNSA9IGRvY3VtZW50ID8gc3RhdGUucGFyc2VyLmRvY3VtZW50IDogc3RhdGUucGFyc2VyLmdldEZyYWdtZW50KClcbiAgY29uc3QgcmVzdWx0ID0gZnJvbVBhcnNlNShwNSwge1xuICAgIC8vIFRvIGRvOiBzdXBwb3J0IGBzcGFjZWA/XG4gICAgZmlsZTogc3RhdGUub3B0aW9ucy5maWxlXG4gIH0pXG5cbiAgaWYgKHN0YXRlLnN0aXRjaGVzKSB7XG4gICAgdmlzaXQocmVzdWx0LCAnY29tbWVudCcsIGZ1bmN0aW9uIChub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gICAgICBjb25zdCBzdGl0Y2ggPSAvKiogQHR5cGUge1N0aXRjaH0gKi8gKC8qKiBAdHlwZSB7dW5rbm93bn0gKi8gKG5vZGUpKVxuICAgICAgaWYgKHN0aXRjaC52YWx1ZS5zdGl0Y2ggJiYgcGFyZW50ICYmIGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxSb290Q29udGVudD59ICovXG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGFzc3VtZSB0aGUgc3RpdGNoIGlzIGFsbG93ZWQuXG4gICAgICAgIHNpYmxpbmdzW2luZGV4XSA9IHN0aXRjaC52YWx1ZS5zdGl0Y2hcbiAgICAgICAgcmV0dXJuIGluZGV4XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIFVucGFjayBpZiBwb3NzaWJsZSBhbmQgd2hlbiBub3QgZ2l2ZW4gYSBgcm9vdGAuXG4gIGlmIChcbiAgICByZXN1bHQudHlwZSA9PT0gJ3Jvb3QnICYmXG4gICAgcmVzdWx0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgIHJlc3VsdC5jaGlsZHJlblswXS50eXBlID09PSB0cmVlLnR5cGVcbiAgKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5jaGlsZHJlblswXVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbGwgbm9kZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PFJvb3RDb250ZW50Pn0gbm9kZXNcbiAqICAgaGFzdCBjb250ZW50LlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gYWxsKG5vZGVzLCBzdGF0ZSkge1xuICBsZXQgaW5kZXggPSAtMVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gaW52YWxpZCBub2Rlcywgc2VlIHJlaHlwZWpzL3JlaHlwZS1yYXcjNy4gKi9cbiAgaWYgKG5vZGVzKSB7XG4gICAgd2hpbGUgKCsraW5kZXggPCBub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmhhbmRsZShub2Rlc1tpbmRleF0pXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcm9vdC5cbiAqXG4gKiBAcGFyYW0ge1Jvb3R9IG5vZGVcbiAqICAgaGFzdCByb290IG5vZGUuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiByb290KG5vZGUsIHN0YXRlKSB7XG4gIGFsbChub2RlLmNoaWxkcmVuLCBzdGF0ZSlcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgaGFzdCBlbGVtZW50IG5vZGUuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBlbGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gIHN0YXJ0VGFnKG5vZGUsIHN0YXRlKVxuXG4gIGFsbChub2RlLmNoaWxkcmVuLCBzdGF0ZSlcblxuICBlbmRUYWcobm9kZSwgc3RhdGUpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgdGV4dC5cbiAqXG4gKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAqICAgaGFzdCB0ZXh0IG5vZGUuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiB0ZXh0KG5vZGUsIHN0YXRlKSB7XG4gIC8vIEFsbG93IGBEQVRBYCB0aHJvdWdoIGBQTEFJTlRFWFRgLFxuICAvLyBidXQgd2hlbiBoYW5naW5nIGluIGEgdGFnIGZvciBleGFtcGxlLFxuICAvLyBzd2l0Y2ggYmFjayB0byBgREFUQWAuXG4gIC8vIE5vdGU6IGBTdGF0ZWAgaXMgbm90IGV4cG9zZWQgYnkgYHBhcnNlNWAsIHNvIHRoZXNlIG51bWJlcnMgYXJlIGZyYWdpbGUuXG4gIC8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9pbmlrdWxpbi9wYXJzZTUvYmxvYi80NmNiYTQzL3BhY2thZ2VzL3BhcnNlNS9saWIvdG9rZW5pemVyL2luZGV4LnRzI0w1OD5cbiAgaWYgKHN0YXRlLnBhcnNlci50b2tlbml6ZXIuc3RhdGUgPiA0KSB7XG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplci5zdGF0ZSA9IDBcbiAgfVxuXG4gIC8qKiBAdHlwZSB7VG9rZW4uQ2hhcmFjdGVyVG9rZW59ICovXG4gIGNvbnN0IHRva2VuID0ge1xuICAgIHR5cGU6IFRva2VuLlRva2VuVHlwZS5DSEFSQUNURVIsXG4gICAgY2hhcnM6IG5vZGUudmFsdWUsXG4gICAgbG9jYXRpb246IGNyZWF0ZVBhcnNlNUxvY2F0aW9uKG5vZGUpXG4gIH1cblxuICByZXNldFRva2VuaXplcihzdGF0ZSwgcG9pbnRTdGFydChub2RlKSlcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgc3RhdGUucGFyc2VyLmN1cnJlbnRUb2tlbiA9IHRva2VuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIHN0YXRlLnBhcnNlci5fcHJvY2Vzc1Rva2VuKHN0YXRlLnBhcnNlci5jdXJyZW50VG9rZW4pXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgZG9jdHlwZS5cbiAqXG4gKiBAcGFyYW0ge0RvY3R5cGV9IG5vZGVcbiAqICAgaGFzdCBkb2N0eXBlIG5vZGUuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBkb2N0eXBlKG5vZGUsIHN0YXRlKSB7XG4gIC8qKiBAdHlwZSB7VG9rZW4uRG9jdHlwZVRva2VufSAqL1xuICBjb25zdCB0b2tlbiA9IHtcbiAgICB0eXBlOiBUb2tlbi5Ub2tlblR5cGUuRE9DVFlQRSxcbiAgICBuYW1lOiAnaHRtbCcsXG4gICAgZm9yY2VRdWlya3M6IGZhbHNlLFxuICAgIHB1YmxpY0lkOiAnJyxcbiAgICBzeXN0ZW1JZDogJycsXG4gICAgbG9jYXRpb246IGNyZWF0ZVBhcnNlNUxvY2F0aW9uKG5vZGUpXG4gIH1cblxuICByZXNldFRva2VuaXplcihzdGF0ZSwgcG9pbnRTdGFydChub2RlKSlcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgc3RhdGUucGFyc2VyLmN1cnJlbnRUb2tlbiA9IHRva2VuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIHN0YXRlLnBhcnNlci5fcHJvY2Vzc1Rva2VuKHN0YXRlLnBhcnNlci5jdXJyZW50VG9rZW4pXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgc3RpdGNoLlxuICpcbiAqIEBwYXJhbSB7Tm9kZXN9IG5vZGVcbiAqICAgdW5rbm93biBub2RlLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gc3RpdGNoKG5vZGUsIHN0YXRlKSB7XG4gIC8vIE1hcmsgdGhhdCB0aGVyZSBhcmUgc3RpdGNoZXMsIHNvIHdlIG5lZWQgdG8gd2FsayB0aGUgdHJlZSBhbmQgcmV2ZXJ0IHRoZW0uXG4gIHN0YXRlLnN0aXRjaGVzID0gdHJ1ZVxuXG4gIC8qKiBAdHlwZSB7Tm9kZXN9ICovXG4gIGNvbnN0IGNsb25lID0gY2xvbmVXaXRob3V0Q2hpbGRyZW4obm9kZSlcblxuICAvLyBSZWN1cnNlLCBiZWNhdXNlIHRvIHNvbWV3aGF0IGhhbmRsZSBgWzx4Pl08L3g+YCAod2hlcmUgYFtdYCBkZW5vdGVzIHRoZVxuICAvLyBwYXNzZWQgdGhyb3VnaCBub2RlKS5cbiAgaWYgKCdjaGlsZHJlbicgaW4gbm9kZSAmJiAnY2hpbGRyZW4nIGluIGNsb25lKSB7XG4gICAgLy8gUm9vdCBpbiByb290IG91dC5cbiAgICBjb25zdCBmYWtlUm9vdCA9IC8qKiBAdHlwZSB7Um9vdH0gKi8gKFxuICAgICAgcmF3KHt0eXBlOiAncm9vdCcsIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVufSwgc3RhdGUub3B0aW9ucylcbiAgICApXG4gICAgY2xvbmUuY2hpbGRyZW4gPSBmYWtlUm9vdC5jaGlsZHJlblxuICB9XG5cbiAgLy8gSGFjazogYHZhbHVlYCBpcyBzdXBwb3NlZCB0byBiZSBhIHN0cmluZywgYnV0IGFzIG5vbmUgb2YgdGhlIHRvb2xzXG4gIC8vIChgcGFyc2U1YCBvciBgaGFzdC11dGlsLWZyb20tcGFyc2U1YCkgbG9va3MgYXQgaXQsIHdlIGNhbiBwYXNzIG5vZGVzXG4gIC8vIHRocm91Z2guXG4gIGNvbW1lbnQoe3R5cGU6ICdjb21tZW50JywgdmFsdWU6IHtzdGl0Y2g6IGNsb25lfX0sIHN0YXRlKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGNvbW1lbnQgKG9yIHN0aXRjaCkuXG4gKlxuICogQHBhcmFtIHtDb21tZW50IHwgU3RpdGNofSBub2RlXG4gKiAgIGhhc3QgY29tbWVudCBub2RlLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gY29tbWVudChub2RlLCBzdGF0ZSkge1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2UgcGFzcyBzdGl0Y2hlcyB0aHJvdWdoLlxuICBjb25zdCBkYXRhID0gbm9kZS52YWx1ZVxuXG4gIC8qKiBAdHlwZSB7VG9rZW4uQ29tbWVudFRva2VufSAqL1xuICBjb25zdCB0b2tlbiA9IHtcbiAgICB0eXBlOiBUb2tlbi5Ub2tlblR5cGUuQ09NTUVOVCxcbiAgICBkYXRhLFxuICAgIGxvY2F0aW9uOiBjcmVhdGVQYXJzZTVMb2NhdGlvbihub2RlKVxuICB9XG4gIHJlc2V0VG9rZW5pemVyKHN0YXRlLCBwb2ludFN0YXJ0KG5vZGUpKVxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICBzdGF0ZS5wYXJzZXIuY3VycmVudFRva2VuID0gdG9rZW5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgc3RhdGUucGFyc2VyLl9wcm9jZXNzVG9rZW4oc3RhdGUucGFyc2VyLmN1cnJlbnRUb2tlbilcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSByYXcgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1Jhd30gbm9kZVxuICogICBoYXN0IHJhdyBub2RlLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUmF3KG5vZGUsIHN0YXRlKSB7XG4gIC8vIFJlc2V0IHByZXByb2Nlc3NvcjpcbiAgLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL2luaWt1bGluL3BhcnNlNS9ibG9iLzZmN2NhNjAvcGFja2FnZXMvcGFyc2U1L2xpYi90b2tlbml6ZXIvcHJlcHJvY2Vzc29yLnRzI0wxOC1MMzE+LlxuICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnByZXByb2Nlc3Nvci5odG1sID0gJydcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IucG9zID0gLTFcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIucHJlcHJvY2Vzc29yLmxhc3RHYXBQb3MgPSAtMlxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IuZ2FwU3RhY2sgPSBbXVxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3Iuc2tpcE5leHROZXdMaW5lID0gZmFsc2VcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IubGFzdENodW5rV3JpdHRlbiA9IGZhbHNlXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIucHJlcHJvY2Vzc29yLmVuZE9mQ2h1bmtIaXQgPSBmYWxzZVxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IuaXNFb2wgPSBmYWxzZVxuXG4gIC8vIE5vdyBwYXNzIGBub2RlLnZhbHVlYC5cbiAgc2V0UG9pbnQoc3RhdGUsIHBvaW50U3RhcnQobm9kZSkpXG5cbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci53cml0ZShcbiAgICBzdGF0ZS5vcHRpb25zLnRhZ2ZpbHRlclxuICAgICAgPyBub2RlLnZhbHVlLnJlcGxhY2UoZ2ZtVGFnZmlsdGVyRXhwcmVzc2lvbiwgJyZsdDskMSQyJylcbiAgICAgIDogbm9kZS52YWx1ZSxcbiAgICBmYWxzZVxuICApXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuX3J1blBhcnNpbmdMb29wKClcblxuICAvLyBDaGFyYWN0ZXIgcmVmZXJlbmNlcyBoYW5nLCBzbyBpZiB3ZSBlbmRlZCB0aGVyZSwgd2UgbmVlZCB0byBmbHVzaFxuICAvLyB0aG9zZSB0b28uXG4gIC8vIFdlIHJlc2V0IHRoZSBwcmVwcm9jZXNzb3IgYXMgaWYgdGhlIGRvY3VtZW50IGVuZHMgaGVyZS5cbiAgLy8gVGhlbiBvbmUgc2luZ2xlIGNhbGwgdG8gdGhlIHJlbGV2YW50IHN0YXRlIGRvZXMgdGhlIHRyaWNrLCBwYXJzZTVcbiAgLy8gY29uc3VtZXMgdGhlIHdob2xlIHRva2VuLlxuXG4gIC8vIE5vdGU6IGBTdGF0ZWAgaXMgbm90IGV4cG9zZWQgYnkgYHBhcnNlNWAsIHNvIHRoZXNlIG51bWJlcnMgYXJlIGZyYWdpbGUuXG4gIC8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9pbmlrdWxpbi9wYXJzZTUvYmxvYi80NmNiYTQzL3BhY2thZ2VzL3BhcnNlNS9saWIvdG9rZW5pemVyL2luZGV4LnRzI0w1OD5cbiAgLy8gTm90ZTogYSBjaGFuZ2UgdG8gYHBhcnNlNWAsIHdoaWNoIGJyZWFrcyB0aGlzLCB3YXMgbWVyZ2VkIGJ1dCBub3QgcmVsZWFzZWQuXG4gIC8vIEludmVzdGlnYXRlIHdoZW4gaXQgaXMuXG4gIC8vIFRvIGRvOiByZW1vdmUgbmV4dCBtYWpvci5cbiAgLyogYzggaWdub3JlIG5leHQgMTIgLS0gcmVtb3ZlZCBpbiA8aHR0cHM6Ly9naXRodWIuY29tL2luaWt1bGluL3BhcnNlNS9wdWxsLzg5Nz4gKi9cbiAgaWYgKFxuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuc3RhdGUgPT09IDcyIC8qIE5BTUVEX0NIQVJBQ1RFUl9SRUZFUkVOQ0UgKi8gfHxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiByZW1vdmVkLlxuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuc3RhdGUgPT09IDc4IC8qIE5VTUVSSUNfQ0hBUkFDVEVSX1JFRkVSRU5DRV9FTkQgKi9cbiAgKSB7XG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IubGFzdENodW5rV3JpdHRlbiA9IHRydWVcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAgIGNvbnN0IGNwID0gc3RhdGUucGFyc2VyLnRva2VuaXplci5fY29uc3VtZSgpXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLl9jYWxsU3RhdGUoY3ApXG4gIH1cbn1cblxuLyoqXG4gKiBDcmFzaCBvbiBhbiB1bmtub3duIG5vZGUuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSBub2RlX1xuICogICB1bmtub3duIG5vZGUuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOZXZlci5cbiAqL1xuZnVuY3Rpb24gdW5rbm93bihub2RlXywgc3RhdGUpIHtcbiAgY29uc3Qgbm9kZSA9IC8qKiBAdHlwZSB7Tm9kZXN9ICovIChub2RlXylcblxuICBpZiAoXG4gICAgc3RhdGUub3B0aW9ucy5wYXNzVGhyb3VnaCAmJlxuICAgIHN0YXRlLm9wdGlvbnMucGFzc1Rocm91Z2guaW5jbHVkZXMobm9kZS50eXBlKVxuICApIHtcbiAgICBzdGl0Y2gobm9kZSwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgbGV0IGV4dHJhID0gJydcblxuICAgIGlmIChrbm93bk1keE5hbWVzLmhhcyhub2RlLnR5cGUpKSB7XG4gICAgICBleHRyYSA9XG4gICAgICAgIFwiLiBJdCBsb29rcyBsaWtlIHlvdSBhcmUgdXNpbmcgTURYIG5vZGVzIHdpdGggYGhhc3QtdXRpbC1yYXdgIChvciBgcmVoeXBlLXJhd2ApLiBJZiB5b3UgdXNlIHRoaXMgYmVjYXVzZSB5b3UgYXJlIHVzaW5nIHJlbWFyayBvciByZWh5cGUgcGx1Z2lucyB0aGF0IGluamVjdCBgJ2h0bWwnYCBub2RlcywgdGhlbiBwbGVhc2UgcmFpc2UgYW4gaXNzdWUgd2l0aCB0aGF0IHBsdWdpbiwgYXMgaXRzIGEgYmFkIGFuZCBzbG93IGlkZWEuIElmIHlvdSB1c2UgdGhpcyBiZWNhdXNlIHlvdSBhcmUgdXNpbmcgbWFya2Rvd24gc3ludGF4LCB0aGVuIHlvdSBoYXZlIHRvIGNvbmZpZ3VyZSB0aGlzIHV0aWxpdHkgKG9yIHBsdWdpbikgdG8gcGFzcyB0aHJvdWdoIHRoZXNlIG5vZGVzIChzZWUgYHBhc3NUaHJvdWdoYCBpbiBkb2NzKSwgYnV0IHlvdSBjYW4gYWxzbyBtaWdyYXRlIHRvIHVzZSB0aGUgTURYIHN5bnRheFwiXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcGlsZSBgJyArIG5vZGUudHlwZSArICdgIG5vZGUnICsgZXh0cmEpXG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldCB0aGUgdG9rZW5pemVyIG9mIGEgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7UG9pbnQgfCB1bmRlZmluZWR9IHBvaW50XG4gKiAgIFBvaW50LlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gcmVzZXRUb2tlbml6ZXIoc3RhdGUsIHBvaW50KSB7XG4gIHNldFBvaW50KHN0YXRlLCBwb2ludClcblxuICAvLyBQcm9jZXNzIGZpbmFsIGNoYXJhY3RlcnMgaWYgdGhleeKAmXJlIHN0aWxsIHRoZXJlIGFmdGVyIGhpYmVybmF0aW5nLlxuICAvKiogQHR5cGUge1Rva2VuLkNoYXJhY3RlclRva2VufSAqL1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICBjb25zdCB0b2tlbiA9IHN0YXRlLnBhcnNlci50b2tlbml6ZXIuY3VycmVudENoYXJhY3RlclRva2VuXG5cbiAgaWYgKHRva2VuICYmIHRva2VuLmxvY2F0aW9uKSB7XG4gICAgdG9rZW4ubG9jYXRpb24uZW5kTGluZSA9IHN0YXRlLnBhcnNlci50b2tlbml6ZXIucHJlcHJvY2Vzc29yLmxpbmVcbiAgICB0b2tlbi5sb2NhdGlvbi5lbmRDb2wgPSBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnByZXByb2Nlc3Nvci5jb2wgKyAxXG4gICAgdG9rZW4ubG9jYXRpb24uZW5kT2Zmc2V0ID0gc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3Iub2Zmc2V0ICsgMVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gICAgc3RhdGUucGFyc2VyLmN1cnJlbnRUb2tlbiA9IHRva2VuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgICBzdGF0ZS5wYXJzZXIuX3Byb2Nlc3NUb2tlbihzdGF0ZS5wYXJzZXIuY3VycmVudFRva2VuKVxuICB9XG5cbiAgLy8gUmVzZXQgdG9rZW5pemVyOlxuICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L2Jsb2IvNmY3Y2E2MC9wYWNrYWdlcy9wYXJzZTUvbGliL3Rva2VuaXplci9pbmRleC50cyNMMTg3LUwyMjM+LlxuICAvLyBFc3BlY2lhbGx5IHB1dHRpbmcgaXQgYmFjayBpbiB0aGUgYGRhdGFgIHN0YXRlIGlzIHVzZWZ1bDogc29tZSBlbGVtZW50cyxcbiAgLy8gbGlrZSB0ZXh0YXJlYXMgYW5kIGlmcmFtZXMsIGNoYW5nZSB0aGUgc3RhdGUuXG4gIC8vIFNlZSBHSC03LlxuICAvLyBCdXQgYWxzbyBpZiBicm9rZW4gSFRNTCBpcyBpbiBgcmF3YCwgYW5kIHRoZW4gYSBjb3JyZWN0IGVsZW1lbnQgaXMgZ2l2ZW4uXG4gIC8vIFNlZSBHSC0xMS5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wYXVzZWQgPSBmYWxzZVxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLmluTG9vcCA9IGZhbHNlXG5cbiAgLy8gTm90ZTogZG9u4oCZdCByZXNldCBgc3RhdGVgLCBgaW5Gb3JlaWduTm9kZWAsIG9yIGBsYXN0U3RhcnRUYWdOYW1lYCwgd2VcbiAgLy8gbWFudWFsbHkgdXBkYXRlIHRob3NlIHdoZW4gbmVlZGVkLlxuICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLmFjdGl2ZSA9IGZhbHNlXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIucmV0dXJuU3RhdGUgPSBUb2tlbml6ZXJNb2RlLkRBVEFcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5jaGFyUmVmQ29kZSA9IC0xXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuY29uc3VtZWRBZnRlclNuYXBzaG90ID0gLTFcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5jdXJyZW50TG9jYXRpb24gPSBudWxsXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuY3VycmVudENoYXJhY3RlclRva2VuID0gbnVsbFxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLmN1cnJlbnRUb2tlbiA9IG51bGxcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5jdXJyZW50QXR0ciA9IHtuYW1lOiAnJywgdmFsdWU6ICcnfVxufVxuXG4vKipcbiAqIFNldCBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7UG9pbnQgfCB1bmRlZmluZWR9IHBvaW50XG4gKiAgIFBvaW50LlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gc2V0UG9pbnQoc3RhdGUsIHBvaW50KSB7XG4gIGlmIChwb2ludCAmJiBwb2ludC5vZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8qKiBAdHlwZSB7VG9rZW4uTG9jYXRpb259ICovXG4gICAgY29uc3QgbG9jYXRpb24gPSB7XG4gICAgICBzdGFydExpbmU6IHBvaW50LmxpbmUsXG4gICAgICBzdGFydENvbDogcG9pbnQuY29sdW1uLFxuICAgICAgc3RhcnRPZmZzZXQ6IHBvaW50Lm9mZnNldCxcbiAgICAgIGVuZExpbmU6IC0xLFxuICAgICAgZW5kQ29sOiAtMSxcbiAgICAgIGVuZE9mZnNldDogLTFcbiAgICB9XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAgIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZXIucHJlcHJvY2Vzc29yLmxpbmVTdGFydFBvcyA9IC1wb2ludC5jb2x1bW4gKyAxIC8vIExvb2tzIHdlaXJkLCBidXQgZW5zdXJlcyB3ZSBnZXQgY29ycmVjdCBwb3NpdGlvbmFsIGluZm8uXG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IuZHJvcHBlZEJ1ZmZlclNpemUgPSBwb2ludC5vZmZzZXRcbiAgICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnByZXByb2Nlc3Nvci5saW5lID0gcG9pbnQubGluZVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplci5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvblxuICB9XG59XG5cbi8qKlxuICogRW1pdCBhIHN0YXJ0IHRhZy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0VGFnKG5vZGUsIHN0YXRlKSB7XG4gIGNvbnN0IHRhZ05hbWUgPSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuXG4gIC8vIElnbm9yZSB0YWdzIGlmIHdl4oCZcmUgaW4gcGxhaW4gdGV4dC5cbiAgaWYgKHN0YXRlLnBhcnNlci50b2tlbml6ZXIuc3RhdGUgPT09IFRva2VuaXplck1vZGUuUExBSU5URVhUKSByZXR1cm5cblxuICByZXNldFRva2VuaXplcihzdGF0ZSwgcG9pbnRTdGFydChub2RlKSlcblxuICBjb25zdCBjdXJyZW50ID0gc3RhdGUucGFyc2VyLm9wZW5FbGVtZW50cy5jdXJyZW50XG4gIGxldCBucyA9ICduYW1lc3BhY2VVUkknIGluIGN1cnJlbnQgPyBjdXJyZW50Lm5hbWVzcGFjZVVSSSA6IHdlYk5hbWVzcGFjZXMuaHRtbFxuXG4gIGlmIChucyA9PT0gd2ViTmFtZXNwYWNlcy5odG1sICYmIHRhZ05hbWUgPT09ICdzdmcnKSB7XG4gICAgbnMgPSB3ZWJOYW1lc3BhY2VzLnN2Z1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gdG9QYXJzZTUoXG4gICAgLy8gU2hhbGxvdyBjbG9uZSB0byBub3QgZGVsdmUgaW50byBgY2hpbGRyZW5gOiB3ZSBvbmx5IG5lZWQgdGhlIGF0dHJpYnV0ZXMuXG4gICAgey4uLm5vZGUsIGNoaWxkcmVuOiBbXX0sXG4gICAge3NwYWNlOiBucyA9PT0gd2ViTmFtZXNwYWNlcy5zdmcgPyAnc3ZnJyA6ICdodG1sJ31cbiAgKVxuXG4gIC8qKiBAdHlwZSB7VG9rZW4uVGFnVG9rZW59ICovXG4gIGNvbnN0IHRhZyA9IHtcbiAgICB0eXBlOiBUb2tlbi5Ub2tlblR5cGUuU1RBUlRfVEFHLFxuICAgIHRhZ05hbWUsXG4gICAgdGFnSUQ6IGh0bWwuZ2V0VGFnSUQodGFnTmFtZSksXG4gICAgLy8gV2UgYWx3YXlzIHNlbmQgc3RhcnQgYW5kIGVuZCB0YWdzLlxuICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICBhY2tTZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgLy8gQWx3YXlzIGVsZW1lbnQuXG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICBhdHRyczogJ2F0dHJzJyBpbiByZXN1bHQgPyByZXN1bHQuYXR0cnMgOiBbXSxcbiAgICBsb2NhdGlvbjogY3JlYXRlUGFyc2U1TG9jYXRpb24obm9kZSlcbiAgfVxuXG4gIC8vIFRoZSBIVE1MIHBhcnNpbmcgYWxnb3JpdGhtIHdvcmtzIGJ5IGRvaW5nIGhhbGYgb2YgdGhlIHN0YXRlIG1hbmFnZW1lbnQgaW5cbiAgLy8gdGhlIHRva2VuaXplciBhbmQgaGFsZiBpbiB0aGUgcGFyc2VyLlxuICAvLyBXZSBjYW7igJl0IHVzZSB0aGUgdG9rZW5pemVyIGhlcmUsIGFzIHdlIGRvbuKAmXQgaGF2ZSBzdHJpbmdzLlxuICAvLyBTbyB3ZSBhY3QgKmFzIGlmKiB0aGUgdG9rZW5pemVyIGVtaXRzIHRva2VuczpcblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICBzdGF0ZS5wYXJzZXIuY3VycmVudFRva2VuID0gdGFnXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIHN0YXRlLnBhcnNlci5fcHJvY2Vzc1Rva2VuKHN0YXRlLnBhcnNlci5jdXJyZW50VG9rZW4pXG5cbiAgLy8g4oCmYnV0IHRoZW4gd2Ugc3RpbGwgbmVlZCBhIGJ1bmNoIG9mIHdvcmsgdGhhdCB0aGUgdG9rZW5pemVyIHdvdWxkIG5vcm1hbGx5XG4gIC8vIGRvLCBzdWNoIGFzOlxuXG4gIC8vIFNldCBhIHRhZyBuYW1lLCBzaW1pbGFyIHRvIGhvdyB0aGUgdG9rZW5pemVyIHdvdWxkIGRvIGl0LlxuICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLmxhc3RTdGFydFRhZ05hbWUgPSB0YWdOYW1lXG5cbiAgLy8gYGluRm9yZWlnbk5vZGVgIGlzIGNvcnJlY3RseSBzZXQgYnkgdGhlIHBhcnNlci5cbn1cblxuLyoqXG4gKiBFbWl0IGFuIGVuZCB0YWcuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiAgIEVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBlbmRUYWcobm9kZSwgc3RhdGUpIHtcbiAgY29uc3QgdGFnTmFtZSA9IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gIC8vIERvIG5vdCBlbWl0IGNsb3NpbmcgdGFncyBmb3IgSFRNTCB2b2lkIGVsZW1lbnRzLlxuICBpZiAoXG4gICAgIXN0YXRlLnBhcnNlci50b2tlbml6ZXIuaW5Gb3JlaWduTm9kZSAmJlxuICAgIGh0bWxWb2lkRWxlbWVudHMuaW5jbHVkZXModGFnTmFtZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBJZ25vcmUgdGFncyBpZiB3ZeKAmXJlIGluIHBsYWluIHRleHQuXG4gIGlmIChzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnN0YXRlID09PSBUb2tlbml6ZXJNb2RlLlBMQUlOVEVYVCkgcmV0dXJuXG5cbiAgcmVzZXRUb2tlbml6ZXIoc3RhdGUsIHBvaW50RW5kKG5vZGUpKVxuXG4gIC8qKiBAdHlwZSB7VG9rZW4uVGFnVG9rZW59ICovXG4gIGNvbnN0IHRhZyA9IHtcbiAgICB0eXBlOiBUb2tlbi5Ub2tlblR5cGUuRU5EX1RBRyxcbiAgICB0YWdOYW1lLFxuICAgIHRhZ0lEOiBodG1sLmdldFRhZ0lEKHRhZ05hbWUpLFxuICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICBhY2tTZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgYXR0cnM6IFtdLFxuICAgIGxvY2F0aW9uOiBjcmVhdGVQYXJzZTVMb2NhdGlvbihub2RlKVxuICB9XG5cbiAgLy8gVGhlIEhUTUwgcGFyc2luZyBhbGdvcml0aG0gd29ya3MgYnkgZG9pbmcgaGFsZiBvZiB0aGUgc3RhdGUgbWFuYWdlbWVudCBpblxuICAvLyB0aGUgdG9rZW5pemVyIGFuZCBoYWxmIGluIHRoZSBwYXJzZXIuXG4gIC8vIFdlIGNhbuKAmXQgdXNlIHRoZSB0b2tlbml6ZXIgaGVyZSwgYXMgd2UgZG9u4oCZdCBoYXZlIHN0cmluZ3MuXG4gIC8vIFNvIHdlIGFjdCAqYXMgaWYqIHRoZSB0b2tlbml6ZXIgZW1pdHMgdG9rZW5zOlxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIHN0YXRlLnBhcnNlci5jdXJyZW50VG9rZW4gPSB0YWdcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgc3RhdGUucGFyc2VyLl9wcm9jZXNzVG9rZW4oc3RhdGUucGFyc2VyLmN1cnJlbnRUb2tlbilcblxuICAvLyDigKZidXQgdGhlbiB3ZSBzdGlsbCBuZWVkIGEgYnVuY2ggb2Ygd29yayB0aGF0IHRoZSB0b2tlbml6ZXIgd291bGQgbm9ybWFsbHlcbiAgLy8gZG8sIHN1Y2ggYXM6XG5cbiAgLy8gU3dpdGNoIGJhY2sgdG8gdGhlIGRhdGEgc3RhdGUgYWZ0ZXIgYWx0ZXJuYXRpdmUgc3RhdGVzIHRoYXQgZG9u4oCZdCBhY2NlcHRcbiAgLy8gdGFnczpcbiAgaWYgKFxuICAgIC8vIEN1cnJlbnQgZWxlbWVudCBpcyBjbG9zZWQuXG4gICAgdGFnTmFtZSA9PT0gc3RhdGUucGFyc2VyLnRva2VuaXplci5sYXN0U3RhcnRUYWdOYW1lICYmXG4gICAgLy8gYDx0ZXh0YXJlYT5gIGFuZCBgPHRpdGxlPmBcbiAgICAoc3RhdGUucGFyc2VyLnRva2VuaXplci5zdGF0ZSA9PT0gVG9rZW5pemVyTW9kZS5SQ0RBVEEgfHxcbiAgICAgIC8vIGA8aWZyYW1lPmAsIGA8bm9lbWJlZD5gLCBgPG5vZnJhbWVzPmAsIGA8c3R5bGU+YCwgYDx4bXA+YFxuICAgICAgc3RhdGUucGFyc2VyLnRva2VuaXplci5zdGF0ZSA9PT0gVG9rZW5pemVyTW9kZS5SQVdURVhUIHx8XG4gICAgICAvLyBgPHNjcmlwdD5gXG4gICAgICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnN0YXRlID09PSBUb2tlbml6ZXJNb2RlLlNDUklQVF9EQVRBKVxuICAgIC8vIE5vdGU6IGA8cGxhaW50ZXh0PmAgbm90IG5lZWRlZCwgYXMgaXTigJlzIHRoZSBsYXN0IGVsZW1lbnQuXG4gICkge1xuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuc3RhdGUgPSBUb2tlbml6ZXJNb2RlLkRBVEFcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGBub2RlYCByZXByZXNlbnRzIGEgd2hvbGUgZG9jdW1lbnQgb3IgYSBmcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGVzfSBub2RlXG4gKiAgIGhhc3Qgbm9kZS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoaXMgcmVwcmVzZW50cyBhIHdob2xlIGRvY3VtZW50IG9yIGEgZnJhZ21lbnQuXG4gKi9cbmZ1bmN0aW9uIGRvY3VtZW50TW9kZShub2RlKSB7XG4gIGNvbnN0IGhlYWQgPSBub2RlLnR5cGUgPT09ICdyb290JyA/IG5vZGUuY2hpbGRyZW5bMF0gOiBub2RlXG4gIHJldHVybiBCb29sZWFuKFxuICAgIGhlYWQgJiZcbiAgICAgIChoZWFkLnR5cGUgPT09ICdkb2N0eXBlJyB8fFxuICAgICAgICAoaGVhZC50eXBlID09PSAnZWxlbWVudCcgJiYgaGVhZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdodG1sJykpXG4gIClcbn1cblxuLyoqXG4gKiBHZXQgYSBgcGFyc2U1YCBsb2NhdGlvbiBmcm9tIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge05vZGVzIHwgU3RpdGNofSBub2RlXG4gKiAgIGhhc3Qgbm9kZS5cbiAqIEByZXR1cm5zIHtUb2tlbi5Mb2NhdGlvbn1cbiAqICAgYHBhcnNlNWAgbG9jYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlNUxvY2F0aW9uKG5vZGUpIHtcbiAgY29uc3Qgc3RhcnQgPSBwb2ludFN0YXJ0KG5vZGUpIHx8IHtcbiAgICBsaW5lOiB1bmRlZmluZWQsXG4gICAgY29sdW1uOiB1bmRlZmluZWQsXG4gICAgb2Zmc2V0OiB1bmRlZmluZWRcbiAgfVxuICBjb25zdCBlbmQgPSBwb2ludEVuZChub2RlKSB8fCB7XG4gICAgbGluZTogdW5kZWZpbmVkLFxuICAgIGNvbHVtbjogdW5kZWZpbmVkLFxuICAgIG9mZnNldDogdW5kZWZpbmVkXG4gIH1cblxuICAvKiogQHR5cGUge1JlY29yZDxrZXlvZiBUb2tlbi5Mb2NhdGlvbiwgbnVtYmVyIHwgdW5kZWZpbmVkPn0gKi9cbiAgY29uc3QgbG9jYXRpb24gPSB7XG4gICAgc3RhcnRMaW5lOiBzdGFydC5saW5lLFxuICAgIHN0YXJ0Q29sOiBzdGFydC5jb2x1bW4sXG4gICAgc3RhcnRPZmZzZXQ6IHN0YXJ0Lm9mZnNldCxcbiAgICBlbmRMaW5lOiBlbmQubGluZSxcbiAgICBlbmRDb2w6IGVuZC5jb2x1bW4sXG4gICAgZW5kT2Zmc2V0OiBlbmQub2Zmc2V0XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiB1bmlzdCBwb2ludCB2YWx1ZXMgY2FuIGJlIGB1bmRlZmluZWRgIGluIGhhc3QsIHdoaWNoXG4gIC8vIGBwYXJzZTVgIHR5cGVzIGRvbuKAmXQgd2FudC5cbiAgcmV0dXJuIGxvY2F0aW9uXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2Rlc30gTm9kZVR5cGVcbiAqICAgTm9kZSB0eXBlLlxuICogQHBhcmFtIHtOb2RlVHlwZX0gbm9kZVxuICogICBOb2RlIHRvIGNsb25lLlxuICogQHJldHVybnMge05vZGVUeXBlfVxuICogICBDbG9uZWQgbm9kZSwgd2l0aG91dCBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY2xvbmVXaXRob3V0Q2hpbGRyZW4obm9kZSkge1xuICByZXR1cm4gJ2NoaWxkcmVuJyBpbiBub2RlXG4gICAgPyBzdHJ1Y3R1cmVkQ2xvbmUoey4uLm5vZGUsIGNoaWxkcmVuOiBbXX0pXG4gICAgOiBzdHJ1Y3R1cmVkQ2xvbmUobm9kZSlcbn1cbiJdLCJuYW1lcyI6WyJzdHJ1Y3R1cmVkQ2xvbmUiLCJmcm9tUGFyc2U1IiwidG9QYXJzZTUiLCJodG1sVm9pZEVsZW1lbnRzIiwiUGFyc2VyIiwiVG9rZW4iLCJUb2tlbml6ZXJNb2RlIiwiaHRtbCIsInBvaW50RW5kIiwicG9pbnRTdGFydCIsInZpc2l0Iiwid2ViTmFtZXNwYWNlcyIsInp3aXRjaCIsImdmbVRhZ2ZpbHRlckV4cHJlc3Npb24iLCJrbm93bk1keE5hbWVzIiwiU2V0IiwicGFyc2VPcHRpb25zIiwic291cmNlQ29kZUxvY2F0aW9uSW5mbyIsInNjcmlwdGluZ0VuYWJsZWQiLCJyYXciLCJ0cmVlIiwib3B0aW9ucyIsImRvY3VtZW50IiwiZG9jdW1lbnRNb2RlIiwib25lIiwiaGFuZGxlcnMiLCJyb290IiwiZWxlbWVudCIsInRleHQiLCJjb21tZW50IiwiZG9jdHlwZSIsImhhbmRsZVJhdyIsInVua25vd24iLCJzdGF0ZSIsInBhcnNlciIsImdldEZyYWdtZW50UGFyc2VyIiwidW5kZWZpbmVkIiwiaGFuZGxlIiwibm9kZSIsInN0aXRjaGVzIiwicmVzZXRUb2tlbml6ZXIiLCJwNSIsImdldEZyYWdtZW50IiwicmVzdWx0IiwiZmlsZSIsImluZGV4IiwicGFyZW50Iiwic3RpdGNoIiwidmFsdWUiLCJzaWJsaW5ncyIsImNoaWxkcmVuIiwidHlwZSIsImxlbmd0aCIsImFsbCIsIm5vZGVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJ0b2tlbml6ZXIiLCJ0b2tlbiIsIlRva2VuVHlwZSIsIkNIQVJBQ1RFUiIsImNoYXJzIiwibG9jYXRpb24iLCJjcmVhdGVQYXJzZTVMb2NhdGlvbiIsImN1cnJlbnRUb2tlbiIsIl9wcm9jZXNzVG9rZW4iLCJET0NUWVBFIiwibmFtZSIsImZvcmNlUXVpcmtzIiwicHVibGljSWQiLCJzeXN0ZW1JZCIsImNsb25lIiwiY2xvbmVXaXRob3V0Q2hpbGRyZW4iLCJmYWtlUm9vdCIsImRhdGEiLCJDT01NRU5UIiwicHJlcHJvY2Vzc29yIiwicG9zIiwibGFzdEdhcFBvcyIsImdhcFN0YWNrIiwic2tpcE5leHROZXdMaW5lIiwibGFzdENodW5rV3JpdHRlbiIsImVuZE9mQ2h1bmtIaXQiLCJpc0VvbCIsInNldFBvaW50Iiwid3JpdGUiLCJ0YWdmaWx0ZXIiLCJyZXBsYWNlIiwiX3J1blBhcnNpbmdMb29wIiwiY3AiLCJfY29uc3VtZSIsIl9jYWxsU3RhdGUiLCJub2RlXyIsInBhc3NUaHJvdWdoIiwiaW5jbHVkZXMiLCJleHRyYSIsImhhcyIsIkVycm9yIiwicG9pbnQiLCJjdXJyZW50Q2hhcmFjdGVyVG9rZW4iLCJlbmRMaW5lIiwibGluZSIsImVuZENvbCIsImNvbCIsImVuZE9mZnNldCIsIm9mZnNldCIsInBhdXNlZCIsImluTG9vcCIsImFjdGl2ZSIsInJldHVyblN0YXRlIiwiREFUQSIsImNoYXJSZWZDb2RlIiwiY29uc3VtZWRBZnRlclNuYXBzaG90IiwiY3VycmVudExvY2F0aW9uIiwiY3VycmVudEF0dHIiLCJzdGFydExpbmUiLCJzdGFydENvbCIsImNvbHVtbiIsInN0YXJ0T2Zmc2V0IiwibGluZVN0YXJ0UG9zIiwiZHJvcHBlZEJ1ZmZlclNpemUiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJQTEFJTlRFWFQiLCJjdXJyZW50Iiwib3BlbkVsZW1lbnRzIiwibnMiLCJuYW1lc3BhY2VVUkkiLCJzdmciLCJzcGFjZSIsInRhZyIsIlNUQVJUX1RBRyIsInRhZ0lEIiwiZ2V0VGFnSUQiLCJzZWxmQ2xvc2luZyIsImFja1NlbGZDbG9zaW5nIiwiYXR0cnMiLCJsYXN0U3RhcnRUYWdOYW1lIiwiaW5Gb3JlaWduTm9kZSIsIkVORF9UQUciLCJSQ0RBVEEiLCJSQVdURVhUIiwiU0NSSVBUX0RBVEEiLCJoZWFkIiwiQm9vbGVhbiIsInN0YXJ0IiwiZW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hast-util-raw/lib/index.js\n");

/***/ })

};
;